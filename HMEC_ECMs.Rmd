
---
title: HMEC ECM Protein Analysis 
author: Mark Dane

output: 
  flexdashboard::flex_dashboard:
    storyboard: true
    source_code: embed
---


```{r "setup", include=FALSE}
knitr::opts_chunk$set(fig.width=12, fig.height=8, echo=FALSE, warning=FALSE, message=FALSE, cache=FALSE)
knitr::opts_knit$set(root.dir = "/data/share/dane/HMEC_ECMs")

```


```{r LoadAndCleanData, cache=FALSE}
#Author: Mark Dane, copyright 2017
library(ggplot2)
library(scales)
library(data.table)
library(MEMA)
library(grid)
library(knitr)
library(gplots)
library(RColorBrewer)
library(DT)
library(d3heatmap)
library(plotly)
library(corrplot)
library(Rtsne)
library(synapseClient)
library(NMF)
library(stringr)

#Setup colors for Barcode and text in all heatmaps
selDark2 <- colorRampPalette(brewer.pal(8,"Dark2"))
plateCol <- selDark2(8)
hmcols<-colorRampPalette(c("blue","white","red"))(16)

normToCOL1Median <- function(dt){
  m <- numericMedian(unlist(dt[dt$ECMp=="COL1",1]))
  if(m==0)stop(paste("Can't normalize when median equals 0",unique(dt$Barcode)))
  r <- dt[,1]-m
}

#Load the latest level 3 SS4 HMEC datasets from Synapse
synapseLogin()
HMEC122L_l3 <- "syn7121240"
HMEC240L_l3 <- "syn7121244"
#Get and clean the datasets
# l3L <- lapply(c(HMEC240L_l3,HMEC122L_l3), function(x){
#   synGet(x) %>%
#     getFileLocation() %>%
#     fread(.,showProgress=FALSE) %>%
#     filter(grepl("FBS",Ligand)) #Filter to only the FBS wells
# })

l3L <- lapply(c("HMEC240L_SS4","HMEC122L_SS4"), function(x){
    fread(paste0("/lincs/share/lincs_user/study/",x,"/Annotated/",x,"_Level3.tsv"),showProgress=FALSE) %>%
    filter(grepl("FBS",Ligand)) #Filter to only the FBS wells
})

#Combine into one data.table
l3 <- rbindlist(l3L)
#Remove FBS plate suffixes
l3$Ligand <- gsub("FBS_P.*","FBS",l3$Ligand)

#Normalize all log and logit signals without doing their SE values
sigNames <- grep("_SE",grep("Log", colnames(l3),value=TRUE),value=TRUE,invert=TRUE)
for(sigName in sigNames){
  l3 <- l3[,sigNameNorm := normToCOL1Median(.SD), .SDcols=c(sigName,"ECMp","Barcode"),by=c("Barcode")]
  setnames(l3,"sigNameNorm",paste0(sigName,"NormCOL1Median"))
}

```


###Experiment Overview


```{r Content Layout, fig.height=5, fig.width=5.5}

#Select the A row wells and delete the blanks
setkey(l3,Well)
dt <- unique(l3[grep("A",unique(l3$Well),value=TRUE),list(ArrayRow,ArrayColumn,ECMp)])
setkey(dt,ECMp)
dt <- dt[!grepl("blank|PBS",dt$ECMp),]

p <- ggplot(data=dt[!grepl("COL1",dt$ECMp),],aes(x = ArrayColumn, y = ArrayRow, fill=ECMp))+
  geom_point(shape=21, size = 2.7)+
  theme(legend.text = element_text(size = rel(.5)),legend.title=element_text(size = rel(.5)),plot.title=element_text(size = rel(.8)))+
  scale_y_reverse()+
  xlab("")+ylab("")+
  ggtitle("MEMA ECM Protein Layout")+
  theme(legend.text=element_text(size = rel(.5)),legend.title=element_text(size = rel(.8)))
p <- p+geom_point(data = dt[grepl("COL1",dt$ECMp),], shape=24, fill="black")
print(p)

#Add SCC pseudoimages


#Well level COL1 Spot Cell Count Boxplots
dt <- l3[grepl("COL1",ECMp),]
p <- ggplot(dt, aes(x=factor(Barcode), y=Spot_PA_SpotCellCount, colour=CellLine))+
  geom_boxplot(outlier.size = .5)+
  xlab("Well Plate Barcode")+ylab("Spot Cell Count")+
  ggtitle("COL1 Spot Cell Count by Plate")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0, hjust=0.5, size=rel(1)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.8)),legend.title=element_text(size = rel(.8)))
print(p)

#Well level Proliferation Boxplots
p <- ggplot(dt, aes(x=factor(Barcode), y=Nuclei_PA_Gated_EdUPositiveProportion, colour=CellLine))+
  geom_boxplot(outlier.size = .5)+
    coord_cartesian(ylim = c(0,1))+
  xlab("Well Plate Barcode")+ylab("Proliferation Proportion")+
  ggtitle("COL1 Proliferation Proportion by Plate")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0, hjust=0.5, size=rel(1)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.8)),legend.title=element_text(size = rel(.8)))
print(p)

#Well level KRT19High Boxplots
p <- ggplot(dt, aes(x=factor(Barcode), y=Cytoplasm_PA_Gated_KRT19PositiveProportion, colour=CellLine))+
  geom_boxplot(outlier.size = .5)+
  coord_cartesian(ylim = c(0,1))+
  xlab("Well Plate Barcode")+ylab("KRT19 High Proportion")+
  ggtitle("COL1 KRT19 High Proportion by Plate")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0, hjust=0.5, size=rel(1)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.8)),legend.title=element_text(size = rel(.8)))
print(p)

#Filter out boxplots that are not good replicates
#filteredPlates <- c("632","633","635","636","638","652","653","655","656","658")
filteredPlates <- c("")
l3f <-l3[!grepl(paste(filteredPlates,collapse = "|"),Barcode),]

l3f<-l3

#Show post filtered boxplots
#Well level COL1 Spot Cell Count Boxplots
dt <- l3f[grepl("COL1",ECMp),]
p <- ggplot(dt, aes(x=factor(Barcode), y=Spot_PA_SpotCellCount, colour=CellLine))+
  geom_boxplot(outlier.size = .5)+
  xlab("Well Plate Barcode")+ylab("Spot Cell Count")+
  ggtitle("COL1 Spot Cell Count by Plate (filtered dataset)")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0, hjust=0.5, size=rel(1)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.8)),legend.title=element_text(size = rel(.8)))
print(p)

#Well level Proliferation Boxplots
p <- ggplot(dt, aes(x=factor(Barcode), y=Nuclei_PA_Gated_EdUPositiveProportion, colour=CellLine))+
  geom_boxplot(outlier.size = .5)+
  coord_cartesian(ylim = c(0,1))+
  xlab("Well Plate Barcode")+ylab("Proliferation Proportion")+
  ggtitle("COL1 Proliferation Proportion by Plate (filtered dataset)")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0, hjust=0.5, size=rel(1)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.8)),legend.title=element_text(size = rel(.8)))
print(p)

#Well level KRT19High Boxplots
p <- ggplot(dt, aes(x=factor(Barcode), y=Cytoplasm_PA_Gated_KRT19PositiveProportion, colour=CellLine))+
  geom_boxplot(outlier.size = .5)+
  coord_cartesian(ylim = c(0,1))+
  xlab("Well Plate Barcode")+ylab("KRT19 High Proportion")+
  ggtitle("COL1 KRT19 High Proportion by Plate (filtered dataset)")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0, hjust=0.5, size=rel(1)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.8)),legend.title=element_text(size = rel(.8)))
print(p)


```

***
This project is a data mining exploration of the signals modulated by the ECM (Extracellular Matrix) proteins in the two MEMA (Microenvironment Microarray) HMEC cell line datasets from Oregon Health and Science University's MEP-LINCS project https://www.synapse.org/#!Synapse:syn2862345/wiki/394513.

There are eight replicate MEMAs in each cell line dataset, each in a different plate. 

All eight plates of a cell line were processed in the wet lab as a batch.

This analysis is based on immunofluorescent cell-level data that has been summarized to the spot and ECM protein levels. 

#####MEMA Layout
All MEMAs in the experiment are in separate wells and have the same design of 48 ECM proteins spotted in 35 rows and 20 columns. The proteins are randomly assigned to spots in the top 30 rows. Rows 31-35 are replicates of rows 1-5. There is a higher number of COL1 spots (shown as black triangles) throughout the array that are control spots. The upper left and bottom right corners of each MEMA are image fiducials in the 488nm channel and there are four blank spots for checking orientation in all channels.

#####Boxplots
The boxplots show spot cell count, proliferation and lineage values for the 99 COL1 controls spots in each well. These wells are replicates within each cell line. 

#####Filtering
Manual review of the replicates leads to filteirng out plates `r filteredPlates`. The remaining MEMAs are used in the follow-on analysis. In addtion, NID1 and ELN are filtered out due to their extreme values.

###Boxplots of Raw and Normalized cell count and proliferation

```{r boxplotsbyECMp, fig.height=5}

dt <- l3f[!grepl("NID1|ELN",ECMp),]

p <- ggplot(dt, aes(x = ECMp, y = 2^Spot_PA_SpotCellCountLog2, fill=CellLine))+
  geom_boxplot()+
  ggtitle(paste("Raw Spot Cell Count by ECM Protein and Cell Line"))+
  xlab("ECM Protein")+ylab("Cells per Spot")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.8)),legend.title=element_text(size = rel(.8)))
suppressWarnings(print(p))


p <- ggplot(dt, aes(x = ECMp, y = 2^Spot_PA_SpotCellCountLog2NormCOL1Median, fill=CellLine))+
  geom_boxplot()+
  #coord_cartesian(ylim=c(0,5))+
  ggtitle(paste("Normalized Spot Cell Count by ECM Protein and Cell Line"))+
  xlab("ECM Protein")+ylab("Normalized Cell Count")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.8)),legend.title=element_text(size = rel(.8)))
p <- p + geom_hline(yintercept = 1, colour="blue", alpha=.5)

suppressWarnings(print(p))

p <- ggplot(dt, aes(x = ECMp, y = btLogit(Nuclei_PA_Gated_EdUPositiveProportionLogit), fill=CellLine))+
  geom_boxplot()+
  ggtitle(paste("Raw Proliferation by ECM Protein and Cell Line"))+
  xlab("ECM Protein")+ylab("Proliferation Proportion")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.8)),legend.title=element_text(size = rel(.8)))
suppressWarnings(print(p))

p <- ggplot(dt, aes(x = ECMp, y = btLogit(Nuclei_PA_Gated_EdUPositiveProportionLogitNormCOL1Median), fill=CellLine))+
  geom_boxplot()+
  #coord_cartesian(ylim=c(0,5))+
  ggtitle(paste("Normalized Proliferation by ECM Protein and Cell Line"))+
  xlab("ECM Protein")+ylab("Normalized Proliferation")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.8)),legend.title=element_text(size = rel(.8)))
p <- p + geom_hline(yintercept = .5, colour="blue", alpha=.5)
suppressWarnings(print(p))

p <- ggplot(dt, aes(x = ECMp, y = btLogit(Cytoplasm_PA_Gated_KRT19PositiveProportionLogit), fill=CellLine))+
  geom_boxplot()+
  ggtitle(paste("Raw KRT19 High Proportion by ECM Protein and Cell Line"))+
  xlab("ECM Protein")+ylab("KRT19 High Proportion")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.8)),legend.title=element_text(size = rel(.8)))
suppressWarnings(print(p))

p <- ggplot(dt, aes(x = ECMp, y = btLogit(Cytoplasm_PA_Gated_KRT19PositiveProportionLogitNormCOL1Median), fill=CellLine))+
  geom_boxplot()+
  #coord_cartesian(ylim=c(0,5))+
  ggtitle(paste("Normalized KRT19 High Proportion by ECM Protein and Cell Line"))+
  xlab("ECM Protein")+ylab("Normalized KRT19 High")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.8)),legend.title=element_text(size = rel(.8)))
p <- p + geom_hline(yintercept = .5, colour="blue", alpha=.5)

suppressWarnings(print(p))
```

***
These boxplots group the replicates across each cell line then stratify them by ECM protein. 

#####Normalization Method
Each value is normalized to the COL1 spots in the same MEMA by log or logit transforming, subtracting the median COL1 value, then backtransforming the results.

###Heatmaps of raw and normalized cell count, proliferation and lineage

```{r heatmapsOfReplicates, fig.height=5}
lowSquishProb <- .04
highSquishProb <- .96

dtc <- dcast(dt,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = "Spot_PA_SpotCellCountLog2", fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc, dimnames=list(dtcRowNames,colnames(dtc)))
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("Raw Spot Cell Count Replicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtcMatrix)))))

dtc <- dcast(dt,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = "Spot_PA_SpotCellCountLog2NormCOL1Median", fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc, dimnames=list(dtcRowNames,colnames(dtc)))
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("Normalized Spot Cell CountReplicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtcMatrix)))))


dtc <- dcast(dt,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = "Nuclei_PA_Gated_EdUPositiveProportion", fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc, dimnames=list(dtcRowNames,colnames(dtc)))
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("Raw Proliferation Replicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtcMatrix)))))


dtc <- dcast(dt,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = "Nuclei_PA_Gated_EdUPositiveProportionLogitNormCOL1Median", fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc)
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("Normalized Proliferation Replicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))


dtc <- dcast(dt,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = "Cytoplasm_PA_Gated_KRT19PositiveProportion", fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc, dimnames=list(dtcRowNames,colnames(dtc)))
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("Raw KRT19 High Replicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtcMatrix)))))


dtc <- dcast(dt,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = "Cytoplasm_PA_Gated_KRT19PositiveProportionLogitNormCOL1Median", fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc)
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("Normalized KRT19 High Replicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))

```

***
These heatmaps are of the raw and normalized cell count, proliferation and lineage signals. To show greater variation in the heatmaps, before clustering the values below the `r lowSquishProb` percentile are set to the `r lowSquishProb` percentile value and values above the `r highSquishProb` percentile and set to the `r highSquishProb` percentile value.

###Heatmaps of the significant signals (Wilcoxon Rank Sum tests)


```{r WilcoxonHeatmapsOfReplicates, fig.height=5}

wilcoxpValues <- function(DT){
  tmp <- wilcox.test(DT[[signalName]][DT$CellLine==unique(DT$CellLine)[1]],
                DT[[signalName]][DT$CellLine==unique(DT$CellLine)[2]])$p.value
}


signalName <- "Spot_PA_SpotCellCountLog2"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
if(dim(dtf)[1]>1){
  dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc, dimnames=list(dtcRowNames,colnames(dtc)))
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("Raw Spot Cell Count Replicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))
}

signalName <- "Spot_PA_SpotCellCountLog2NormCOL1Median"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
if(dim(dtf)[1]>1){
  dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
  dtcRowNames <- dtc$ECMp
  dtc <- dtc[,ECMp:=NULL]
  dtcMatrix <- as.matrix(dtc, dimnames=list(dtcRowNames,colnames(dtc)))
  #Compress the tails to show more variation within the distributions
  dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
  dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
  rownames(dtcMatrix)<-dtcRowNames
  colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
   if(dim(dtcMatrix)[1]==1) dtcMatrix <- rbind(dtcMatrix,dtcMatrix)
    aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
             main=paste("Normalized Spot Cell CountReplicates"),
             annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))
}

signalName <- "Nuclei_PA_Gated_EdUPositiveProportion"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc, dimnames=list(dtcRowNames,colnames(dtc)))
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("Raw Proliferation Replicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))

signalName <- "Nuclei_PA_Gated_EdUPositiveProportionLogitNormCOL1Median"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
if(dim(dtf)[1]>1){
dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc)
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("Normalized Proliferation Replicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))
}

signalName <- "Cytoplasm_PA_Gated_KRT19PositiveProportion"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc, dimnames=list(dtcRowNames,colnames(dtc)))
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("Raw KRT19 High Replicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))

signalName <- "Cytoplasm_PA_Gated_KRT19PositiveProportionLogitNormCOL1Median"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
if(dim(dtf)[1]>1){
  dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
  dtcRowNames <- dtc$ECMp
  dtc <- dtc[,ECMp:=NULL]
  dtcMatrix <- as.matrix(dtc)
  #Compress the tails to show more variation within the distributions
  dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
  dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
  rownames(dtcMatrix)<-dtcRowNames
  colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
  aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
           main=paste("Normalized KRT19 High Replicates"),
           annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))
}

```

***
These heatmaps are of the raw and normalized cell count, proliferation and lineage signals that have significant differences(Wilcoxon Rank Sum test with fdr=.2) in the responses across cell lines. To show greater variation in the heatmaps, before clustering the values below the `r lowSquishProb` percentile are set to the `r lowSquishProb` percentile value and values above the `r highSquishProb` percentile and set to the `r highSquishProb` percentile value.

###Heatmaps of the RUV normalized significant signals (Wilcoxon Rank Sum tests)


```{r WilcoxonHeatmapsOfReplicatesRUV, fig.height=5}

signalName <- "Spot_PA_SpotCellCountLog2RUVLoess"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
if(dim(dtf)[1]>1){
  dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc, dimnames=list(dtcRowNames,colnames(dtc)))
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("RUV Normalized Spot Cell Count Replicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))
}

signalName <- "Spot_PA_SpotCellCountLog2RUVLoessNormCOL1Median"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
if(dim(dtf)[1]>1){
  dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
  dtcRowNames <- dtc$ECMp
  dtc <- dtc[,ECMp:=NULL]
  dtcMatrix <- as.matrix(dtc, dimnames=list(dtcRowNames,colnames(dtc)))
  #Compress the tails to show more variation within the distributions
  dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
  dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
  rownames(dtcMatrix)<-dtcRowNames
  colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
   if(dim(dtcMatrix)[1]==1) dtcMatrix <- rbind(dtcMatrix,dtcMatrix)
    aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
             main=paste("RUV and COL1 Normalized Spot Cell CountReplicates"),
             annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))
}

signalName <- "Nuclei_PA_Gated_EdUPositiveProportionLogitRUVLoess"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc, dimnames=list(dtcRowNames,colnames(dtc)))
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("RUV Normalized Proliferation Replicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))

signalName <- "Nuclei_PA_Gated_EdUPositiveProportionLogitRUVLoessNormCOL1Median"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
if(dim(dtf)[1]>1){
dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc)
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("RUV and COL1 Normalized Proliferation Replicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))
}

signalName <- "Cytoplasm_PA_Gated_KRT19PositiveProportionLogitRUVLoess"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc, dimnames=list(dtcRowNames,colnames(dtc)))
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("RUV Normalized KRT19 High Replicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))

signalName <- "Cytoplasm_PA_Gated_KRT19PositiveProportionLogitRUVLoessNormCOL1Median"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
if(dim(dtf)[1]>1){
  dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
  dtcRowNames <- dtc$ECMp
  dtc <- dtc[,ECMp:=NULL]
  dtcMatrix <- as.matrix(dtc)
  #Compress the tails to show more variation within the distributions
  dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
  dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
  rownames(dtcMatrix)<-dtcRowNames
  colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
  aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
           main=paste("RUV and COL1 Normalized KRT19 High Replicates"),
           annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))
}

```

***
These heatmaps are of the RUV and RUV+COL1 and normalized cell count, proliferation and lineage signals that have significant differences(Wilcoxon Rank Sum test with fdr=.2) in the responses across cell lines. To show greater variation in the heatmaps, before clustering the values below the `r lowSquishProb` percentile are set to the `r lowSquishProb` percentile value and values above the `r highSquishProb` percentile and set to the `r highSquishProb` percentile value.

###PCA of all normalized signals

```{r, fig.height=3,fig.width=4}

createPCAModel <- function(dt,fvNames,verbose=FALSE){
  #delete any non-varying signals that cannot be scaled to unit variance
  stdDevs <- apply(dt[,fvNames, with=FALSE], 2, sd)
  if(any(stdDevs==0)&verbose)  cat(paste("Deleting",fvNames[stdDevs==0], "due to 0 variance\n"))
  fvNames <- fvNames[!stdDevs==0]
  PCAModel <- prcomp(as.formula(paste(" ~ ", paste(fvNames, collapse = "+"))), data = dt, scale.= TRUE)
  rownames(PCAModel$x)<-paste(dt$MEP,gsub("LI8X00","",dt$Barcode), sep="_")
  return(PCAModel)
}

###PCA Unbiased Analysis  

#Get a PCA model of the COL1 normalized data
COL1NormFVNames <- grep("COL1Median",colnames(l3f), value=TRUE)
#Median summarize the signals to the MEP/ECMp level
mc <- l3f[!grepl("NID1|ELN",ECMp),lapply(.SD,numericMedian), by=c("ECMp","CellLine"),.SDcols=COL1NormFVNames]
MEPs <- mc[,lapply(.SD,diff), by=c("ECMp"),.SDcols=COL1NormFVNames]
COL1NormPCAModel <- createPCAModel(dt=MEPs, fvNames = COL1NormFVNames)

###PCA of normalized spot

xlim<-c(-10,10)
ylim<-c(-10,10)
dt <- cbind(data.table(COL1NormPCAModel$x), ECMp=MEPs$ECMp)

p12 <- ggplot(dt, aes(x = PC1, y = PC2, colour = ECMp)) +
      geom_point(size = rel(.8), alpha = .6) +
      labs(colour = "ECM Protein")+
      ggtitle("PCA of The Cell Line Differences of All Normalized Signals")+
      #coord_cartesian(xlim=xlim, ylim=ylim)+
      theme(legend.text=element_text(size = 6),
            plot.title=element_text(size = rel(.7)))
ggplotly(p12)

```

***
####Method
The responses in all normalized signals are first median summerized across the replicates.  
Next, the differences between the cell lines are calculated.  
PCA is run on the differences to reduce from `r length(COL1NormFVNames)` signals.  
The scatterplot shows the first 2 principal components of all normalized signals, colored by ECM protein. Hovering over a spot shows its ECM protein. 
