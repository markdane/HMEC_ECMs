
---
title: HMEC ECM Protein Analysis 
author: Mark Dane

output: 
  flexdashboard::flex_dashboard:
    storyboard: true
    source_code: embed
---


```{r "setup", include=FALSE}
knitr::opts_chunk$set(fig.width=12, fig.height=8, echo=FALSE, warning=FALSE, message=FALSE, cache=FALSE)
knitr::opts_knit$set(root.dir = "/data/share/dane/HMEC_ECMs")

```


```{r LoadAndCleanData, cache=FALSE}
#Author: Mark Dane, copyright 2017
library(ggplot2)
library(scales)
library(data.table)
library(MEMA)
library(grid)
library(knitr)
library(gplots)
library(RColorBrewer)
library(DT)
library(d3heatmap)
library(plotly)
library(corrplot)
library(Rtsne)
library(synapseClient)
library(NMF)
library(stringr)

#Setup colors for Barcode and text in all heatmaps
selDark2 <- colorRampPalette(brewer.pal(8,"Dark2"))
plateCol <- selDark2(8)
hmcols<-colorRampPalette(c("blue","white","red"))(16)

normToCOL1Median <- function(dt){
  m <- numericMedian(unlist(dt[dt$ECMp=="COL1",1]))
  if(m==0)stop(paste("Can't normalize when median equals 0",unique(dt$Barcode),colnames(dt)))
  r <- dt[,1]/m
}

#Load the latest level 3 SS4 HMEC datasets from Synapse
synapseLogin()
HMEC122L_l3 <- "syn8565101"
HMEC240L_l3 <- "syn8606270"
#Get and clean the datasets
l3L <- lapply(c(HMEC240L_l3,HMEC122L_l3), function(x){
  synGet(x) %>%
    getFileLocation() %>%
    fread(.,showProgress=FALSE) %>%
    filter(grepl("FBS",Ligand)) #Filter to only the FBS wells
})

#Combine into one data.table
l3 <- rbindlist(l3L)

#Normalize all log and logit signals without doing their SE values
sigNames <- grep("_SE",grep("Norm$", colnames(l3),value=TRUE),value=TRUE,invert=TRUE)
for(sigName in sigNames){
l3 <- l3[,sigNameNorm := normToCOL1Median(.SD), .SDcols=c(sigName,"ECMp","Barcode"),by=c("Barcode")]
setnames(l3,"sigNameNorm",paste0(sigName,"COL1MedianNorm"))
}

```


###Experiment Overview


```{r Content Layout, fig.height=5, fig.width=5.5}

#Select the A row wells and delete the blanks
setkey(l3,Well)
dt <- unique(l3[grep("A",unique(l3$Well),value=TRUE),list(ArrayRow,ArrayColumn,ECMp)])
setkey(dt,ECMp)
dt <- dt[!grepl("blank|PBS",dt$ECMp),]

p <- ggplot(data=dt[!grepl("COL1",dt$ECMp),],aes(x = ArrayColumn, y = ArrayRow, fill=ECMp))+
  geom_point(shape=21, size = 2.7)+
  theme(legend.text = element_text(size = rel(.5)),legend.title=element_text(size = rel(.5)),plot.title=element_text(size = rel(.8)))+
  scale_y_reverse()+
  xlab("")+ylab("")+
  ggtitle("MEMA ECM Protein Layout")+
  theme(legend.text=element_text(size = rel(.5)),legend.title=element_text(size = rel(.8)))
p <- p+geom_point(data = dt[grepl("COL1",dt$ECMp),], shape=24, fill="black")
print(p)

#Well level COL1 Spot Cell Count Boxplots
dt <- l3[grepl("COL1",ECMp),]
#Melt the spot cell count value to show effects of normalization
dtm <- suppressWarnings(melt(dt, id.vars = c("Barcode"),measure.vars = c("Spot_PA_SpotCellCount","Spot_PA_SpotCellCountNorm","Spot_PA_SpotCellCountNormCOL1MedianNorm"), variable.name = "ProcessLevel",value.name = "Spot_Cell_Count", factorsAsstrings=FALSE))
levels(dtm$ProcessLevel) <- c("Raw","RUVLoessResidual","RUVLoessResidualandCol1")

p <- ggplot(dtm, aes(x=Barcode, y=Spot_Cell_Count, colour=ProcessLevel))+
  geom_boxplot(outlier.size = .5)+
  xlab("Well Plate Barcode")+ylab("Spot Cell Count")+
  ggtitle("Normalization Results of COL1 Spot Cell Count by Plate")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0, hjust=0.5, size=rel(1)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.8)),legend.title=element_text(size = rel(.8)))

print(p)

#ECMp Spot cell counts Boxplots
p <- ggplot(l3, aes(x=factor(ECMp), y=Spot_PA_SpotCellCountNormCOL1MedianNorm))+
  geom_boxplot(outlier.size = .5)+
  xlab("Well Plate Barcode")+ylab("Normalized Spot Cell Count")+
  ggtitle("Normalized COL1 Spot Cell Count Proportion by ECM Protein")+
  facet_wrap(~CellLine)+
  theme(axis.text.x = element_text(angle = 90, vjust = 0, hjust=0.5, size=rel(1)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.8)),legend.title=element_text(size = rel(.8)))
p <- p + geom_hline(yintercept = 1, colour="blue")
print(p)

#Well level Proliferation Boxplots
p <- ggplot(l3, aes(x=factor(ECMp), y=Nuclei_PA_Gated_EdUPositiveProportionNormCOL1MedianNorm, colour=CellLine))+
  geom_boxplot(outlier.size = .5)+
  #coord_cartesian(ylim = c(0,1))+
  xlab("Well Plate Barcode")+ylab("Proliferation Proportion")+
  ggtitle("Normalized COL1 Proliferation Proportion by ECM Protein")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0, hjust=0.5, size=rel(1)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.8)),legend.title=element_text(size = rel(.8)))
print(p)

#Well level KRT19High Boxplots
p <- ggplot(l3, aes(x=factor(ECMp), y=Cytoplasm_PA_Gated_KRT19PositiveProportionNormCOL1MedianNorm, colour=CellLine))+
  geom_boxplot(outlier.size = .5)+
  #coord_cartesian(ylim = c(0,1))+
  xlab("Well Plate Barcode")+ylab("KRT19 High Proportion")+
  ggtitle("Normalized COL1 KRT19 High Proportion by ECM Protein")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0, hjust=0.5, size=rel(1)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.8)),legend.title=element_text(size = rel(.8)))
print(p)


```

***
This project is a data mining exploration of the signals modulated by the ECM (Extracellular Matrix) proteins in the two MEMA (Microenvironment Microarray) HMEC cell line datasets from Oregon Health and Science University's MEP-LINCS project https://www.synapse.org/#!Synapse:syn2862345/wiki/394513.

There are eight replicate MEMAs in each cellline dataset, each in a different plate. 
All eight replicates of a cell line were processed in the wet lab as a batch.

This analysis is based on immunofluorescent cell-level data that has been summarized to the spot and ECM protein levels. 

#####MEMA Layout
All MEMAs in the experiment are in separate wells and have the same design of 48 ECM proteins spotted in 35 rows and 20 columns. The proteins are randomly assigned to spots in the top 30 rows. Rows 31-35 are replicates of rows 1-5. There is a higher number of COL1 spots (shown as black triangles) throughout the array that are control spots. The upper left and bottom right corners of each MEMA are image fiducials in the 488nm channel and there are four blank spots for checking orientation in all channels.

#####Boxplots
This dataset has raw, RUVLoessResidual normalized and RUVLoessResidual normalized that has then been normalized to the collagen 1 spots in the same MEMA. These figures show results of these three states of processing.

The following boxplots show the fully normalized values for spot cell count, EdU positive proportion and KRT19 high positive proportion for each ECM protein and cell line. Each boxplot contains data from 80-120 replicate spots that come from 8 different plates.  


###Heatmaps of the significant signals (Wilcoxon Rank Sum tests)


```{r WilcoxonHeatmapsOfReplicates, fig.height=5}

wilcoxpValues <- function(DT){
  tmp <- wilcox.test(DT[[signalName]][DT$CellLine==unique(DT$CellLine)[1]],
                DT[[signalName]][DT$CellLine==unique(DT$CellLine)[2]])$p.value
}


signalName <- "Spot_PA_SpotCellCount"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
if(dim(dtf)[1]>1){
  dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc, dimnames=list(dtcRowNames,colnames(dtc)))
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("Raw Spot Cell Count Replicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))
}

signalName <- "Spot_PA_SpotCellCountNormCOL1MedianNorm"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
if(dim(dtf)[1]>1){
  dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
  dtcRowNames <- dtc$ECMp
  dtc <- dtc[,ECMp:=NULL]
  dtcMatrix <- as.matrix(dtc, dimnames=list(dtcRowNames,colnames(dtc)))
  #Compress the tails to show more variation within the distributions
  dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
  dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
  rownames(dtcMatrix)<-dtcRowNames
  colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
   if(dim(dtcMatrix)[1]==1) dtcMatrix <- rbind(dtcMatrix,dtcMatrix)
    aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
             main=paste("Normalized Spot Cell CountReplicates"),
             annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))
}

signalName <- "Nuclei_PA_Gated_EdUPositiveProportion"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc, dimnames=list(dtcRowNames,colnames(dtc)))
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("Raw Proliferation Replicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))

signalName <- "Nuclei_PA_Gated_EdUPositiveProportionNormCOL1MedianNorm"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
if(dim(dtf)[1]>1){
dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc)
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("Normalized Proliferation Replicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))
}

signalName <- "Cytoplasm_PA_Gated_KRT19PositiveProportion"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc, dimnames=list(dtcRowNames,colnames(dtc)))
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("Raw KRT19 High Replicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))

signalName <- "Cytoplasm_PA_Gated_KRT19PositiveProportionNormCOL1MedianNorm"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
if(dim(dtf)[1]>1){
  dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
  dtcRowNames <- dtc$ECMp
  dtc <- dtc[,ECMp:=NULL]
  dtcMatrix <- as.matrix(dtc)
  #Compress the tails to show more variation within the distributions
  dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
  dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
  rownames(dtcMatrix)<-dtcRowNames
  colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
  aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
           main=paste("Normalized KRT19 High Replicates"),
           annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))
}

```

***
These heatmaps are of the raw and normalized cell count, proliferation and lineage signals that have significant differences(Wilcoxon Rank Sum test with fdr=.2) in the responses across cell lines. To show greater variation in the heatmaps, before clustering the values below the `r lowSquishProb` percentile are set to the `r lowSquishProb` percentile value and values above the `r highSquishProb` percentile and set to the `r highSquishProb` percentile value.

###Heatmaps of the RUV normalized significant signals (Wilcoxon Rank Sum tests)


```{r WilcoxonHeatmapsOfReplicatesRUV, fig.height=5}

signalName <- "Spot_PA_SpotCellCountNorm"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
if(dim(dtf)[1]>1){
  dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc, dimnames=list(dtcRowNames,colnames(dtc)))
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("Normalized Spot Cell Count Replicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))
}

signalName <- "Spot_PA_SpotCellCountNormCOL1MedianNorm"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
if(dim(dtf)[1]>1){
  dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
  dtcRowNames <- dtc$ECMp
  dtc <- dtc[,ECMp:=NULL]
  dtcMatrix <- as.matrix(dtc, dimnames=list(dtcRowNames,colnames(dtc)))
  #Compress the tails to show more variation within the distributions
  dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
  dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
  rownames(dtcMatrix)<-dtcRowNames
  colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
   if(dim(dtcMatrix)[1]==1) dtcMatrix <- rbind(dtcMatrix,dtcMatrix)
    aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
             main=paste("RUVLoessResidual and COL1 Normalized Spot Cell CountReplicates"),
             annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))
}

signalName <- "Nuclei_PA_Gated_EdUPositiveProportionNorm"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc, dimnames=list(dtcRowNames,colnames(dtc)))
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("RUV Normalized Proliferation Replicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))

signalName <- "Nuclei_PA_Gated_EdUPositiveProportionNormCOL1MedianNorm"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
if(dim(dtf)[1]>1){
dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc)
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("RUV and COL1 Normalized Proliferation Replicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))
}

signalName <- "Cytoplasm_PA_Gated_KRT19PositiveProportionNorm"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
dtcRowNames <- dtc$ECMp
dtc <- dtc[,ECMp:=NULL]
dtcMatrix <- as.matrix(dtc, dimnames=list(dtcRowNames,colnames(dtc)))
#Compress the tails to show more variation within the distributions
dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
rownames(dtcMatrix)<-dtcRowNames
colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
          main=paste("RUV Normalized KRT19 High Replicates"),
        annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))

signalName <- "Cytoplasm_PA_Gated_KRT19PositiveProportionNormCOL1MedianNorm"
dtp <- dt[,.(wilcoxPValue=wilcoxpValues(.SD)),by="ECMp",.SDcols=c("CellLine",signalName)]
dtp <- dtp[,pAdjusted := p.adjust(wilcoxPValue,method="fdr")]
dtf <- dt[dt$ECMp %in% dtp$ECMp[dtp$pAdjusted<0.2],]
if(dim(dtf)[1]>1){
  dtc <- dcast(dtf,ECMp~Barcode+CellLine,fun.aggregate = median, value.var = signalName, fill=NA)
  dtcRowNames <- dtc$ECMp
  dtc <- dtc[,ECMp:=NULL]
  dtcMatrix <- as.matrix(dtc)
  #Compress the tails to show more variation within the distributions
  dtcMatrix[dtcMatrix < quantile(dtcMatrix,probs = lowSquishProb)] <- quantile(dtcMatrix,probs = lowSquishProb)
  dtcMatrix[dtcMatrix > quantile(dtcMatrix,probs = highSquishProb)] <- quantile(dtcMatrix,probs = highSquishProb)
  rownames(dtcMatrix)<-dtcRowNames
  colnames(dtcMatrix) <- gsub("_.*","",colnames(dtc))
  aheatmap(dtcMatrix, col=hmcols, cexRow=.6, cexCol=.5,
           main=paste("RUV and COL1 Normalized KRT19 High Replicates"),
           annCol = list(CellLine=as.factor(gsub(".*_","",colnames(dtc)))))
}

```

***
These heatmaps are of the RUV and RUV+COL1 and normalized cell count, proliferation and lineage signals that have significant differences(Wilcoxon Rank Sum test with fdr=.2) in the responses across cell lines. To show greater variation in the heatmaps, before clustering the values below the `r lowSquishProb` percentile are set to the `r lowSquishProb` percentile value and values above the `r highSquishProb` percentile and set to the `r highSquishProb` percentile value.

###Scatterplots of the RUVLoessResiduals normalized signals


```{r ScatterplotsOfReplicatesRUV, fig.height=4, fig.width=7}

compScatterplots <- function(dt,sig,title,limits,sdInt=.25) {
  dtc <- dcast(dt,ECMp~CellLine,fun.aggregate = median, value.var = sig, fill=NA)
  p <- ggplot(dtc, aes(x=HMEC122L, y=HMEC240L, colour=ECMp))+
    geom_point(size = rel(1), alpha = .6) +
    guides(colour=FALSE)+
    labs(colour = "ECM Protein")+
    ggtitle(title)+
    coord_cartesian(xlim=limits, ylim=limits)+
    theme(legend.text=element_text(size = 5),
          plot.title=element_text(size = rel(.7)))
  p <- p + geom_abline(slope = 1,intercept = 0)
  p <- p + geom_abline(slope = 1,intercept = sdInt, linetype=2)
  p <- p + geom_abline(slope = 1,intercept = -sdInt, linetype=2)
  print(p)
}

dt <- l3[!grepl("NID1|ELN",ECMp),]

#Select the COL1+RUV normalized values
COL1NormFVNames <- grep("NormCOL1MedianNorm",colnames(l3), value=TRUE)
#Median summarize the signals to the MEP/ECMp level within each cell line
mc <- l3[!grepl("NID1|ELN",ECMp),lapply(.SD,numericMedian), by=c("ECMp","CellLine"),.SDcols=COL1NormFVNames]
#Calculate the difference between the cell lines
MEPs <- mc[,lapply(.SD,diff), by=c("ECMp"),.SDcols=COL1NormFVNames]

compScatterplots(dt, sig = "Spot_PA_SpotCellCountNormCOL1MedianNorm",title = "Comparison of RUV+COL1 Normalized Spot Cell Counts\n in the HMEC Cell Lines",limits=c(-.5,.7), sdInt = sd(MEPs$Spot_PA_SpotCellCountNormCOL1MedianNorm))
compScatterplots(dt,sig = "Nuclei_PA_Gated_EdUPositiveProportionNormCOL1MedianNorm",title = "Comparison of RUV+COL1 Normalized Proliferation\n in the HMEC Cell Lines",limits=c(-.5,1), sdInt = sd(MEPs$Nuclei_PA_Gated_EdUPositiveProportionNormCOL1MedianNorm))
compScatterplots(dt, sig = "Cytoplasm_PA_Gated_KRT19PositiveProportionNormCOL1MedianNorm",title = "Comparison of RUV+COL1 Normalized Luminal Signal\n  in the HMEC Cell Lines",limits=c(-1,.6), sdInt = sd(MEPs$Cytoplasm_PA_Gated_KRT19PositiveProportionNormCOL1MedianNorm))

```

***
These scatterplots are of the RUV+COL1 normalized cell count, proliferation and lineage signals. The diagonal lines have slope=1 and are for reference.

###PCA of all normalized signals

```{r, fig.height=3,fig.width=4}

createPCAModel <- function(dt,fvNames,verbose=FALSE){
  #delete any non-varying signals that cannot be scaled to unit variance
  stdDevs <- apply(dt[,fvNames, with=FALSE], 2, sd)
  if(any(stdDevs==0)&verbose)  cat(paste("Deleting",fvNames[stdDevs==0], "due to 0 variance\n"))
  fvNames <- fvNames[!stdDevs==0]
  PCAModel <- prcomp(as.formula(paste(" ~ ", paste(fvNames, collapse = "+"))), data = dt, scale.= TRUE)
  rownames(PCAModel$x)<-paste(dt$MEP,gsub("LI8X00","",dt$Barcode), sep="_")
  return(PCAModel)
}

plotScree <- function(m,nrPCs=9,main  = paste("PCA Scree Plot")){
  var <- m$sd[1:nrPCs]^2
  var.percent <- var/sum(var) * 100
  barplot(var.percent, xlab="PC", ylab="Percent Variance", names.arg=1:length(var.percent), las=1, ylim=c(0,max(var.percent)), col="gray", main=main)
}


#Get a PCA model of the RUV+COL1 normalized data
COL1NormPCAModel <- createPCAModel(dt=MEPs, fvNames = COL1NormFVNames)
dt <- cbind(data.table(COL1NormPCAModel$x), ECMp=MEPs$ECMp)

plotScree(COL1NormPCAModel)

p12 <- ggplot(dt, aes(x = PC1, y = PC2, colour = ECMp)) +
      geom_point(size = rel(2), alpha = .8) +
      ggtitle("PCA of The Cell Line Differences of All RUV+COL1 Normalized Signals")+
      #coord_cartesian(xlim=xlim, ylim=ylim)+
  guides(colour=FALSE)+
      theme(legend.text=element_text(size = 6),
            plot.title=element_text(size = rel(.7)))
p12

p13 <- ggplot(dt, aes(x = PC1, y = PC3, colour = ECMp)) +
      geom_point(size = rel(2), alpha = .8) +
      ggtitle("PCA of The Cell Line Differences of All RUV+COL1 Normalized Signals")+
      #coord_cartesian(xlim=xlim, ylim=ylim)+
  guides(colour=FALSE)+
      theme(legend.text=element_text(size = 6),
            plot.title=element_text(size = rel(.7)))
p13

p23 <- ggplot(dt, aes(x = PC2, y = PC3, colour = ECMp)) +
      geom_point(size = rel(2), alpha = .8) +
      ggtitle("PCA of The Cell Line Differences of All RUV+COL1 Normalized Signals")+
      #coord_cartesian(xlim=xlim, ylim=ylim)+
  guides(colour=FALSE)+
      theme(legend.text=element_text(size = 6),
            plot.title=element_text(size = rel(.7)))
p23

p14 <- ggplot(dt, aes(x = PC1, y = PC4, colour = ECMp)) +
      geom_point(size = rel(2), alpha = .8) +
    guides(colour=FALSE)+
      ggtitle("PCA of The Cell Line Differences of All RUV+COL1 Normalized Signals")+
      #coord_cartesian(xlim=xlim, ylim=ylim)+
      theme(legend.text=element_text(size = 6),
            plot.title=element_text(size = rel(.7)))
p14

```

###Interactive PCA of all RUV+Col1 Normalized Signals

```{r, fig.height=3,fig.width=4}

p12 <- ggplot(dt, aes(x = PC1, y = PC2, colour = ECMp)) +
      geom_point(size = rel(2), alpha = .8) +
      labs(colour = "ECM Protein")+
      ggtitle("PCA of The Cell Line Differences of All RUV+COL1 Normalized Signals")+
      #coord_cartesian(xlim=xlim, ylim=ylim)+
      theme(legend.text=element_text(size = 6),
            plot.title=element_text(size = rel(.7)))
ggplotly(p12)

```

***

####Method
The responses in all normalized signals are first median summerized across the replicates.  
Next, the differences between the cell lines are calculated.  
PCA is run on the differences to reduce from `r length(COL1NormFVNames)` signals.  
The scatterplot shows the first 2 principal components of all normalized signals, colored by ECM protein. Hovering over a spot shows its ECM protein. 


###Interactive Scatterplot of RUV+Col1 Normalized Spot Cell Count

```{r, scatterPlotlySCC, fig.height=3,fig.width=4}


compScatterplotly <- function(dt,sig,title,limits,sdInt=.25) {
  dtc <- dcast(dt,ECMp~CellLine,fun.aggregate = median, value.var = sig, fill=NA)
  p <- ggplot(dtc, aes(x=HMEC122L, y=HMEC240L, colour=ECMp))+
    geom_point(size = rel(2), alpha = .6) +
    labs(colour = "ECM Protein")+
    ggtitle(title)+
    coord_cartesian(xlim=limits, ylim=limits)+
    theme(legend.text=element_text(size = 5),
          plot.title=element_text(size = rel(.7)))
  p <- p + geom_abline(slope = 1,intercept = 0)
  p <- p + geom_abline(slope = 1,intercept = sdInt, linetype=2)
  p <- p + geom_abline(slope = 1,intercept = -sdInt, linetype=2)
  ggplotly(p)
}

dt <- l3[!grepl("NID1|ELN",ECMp),]

#Select the COL1+RUV normalized values
COL1NormFVNames <- grep("NormCOL1MedianNorm",colnames(l3), value=TRUE)
#Median summarize the signals to the MEP/ECMp level within each cell line
mc <- l3[!grepl("NID1|ELN",ECMp),lapply(.SD,numericMedian), by=c("ECMp","CellLine"),.SDcols=COL1NormFVNames]
#Calculate the difference between the cell lines
MEPs <- mc[,lapply(.SD,diff), by=c("ECMp"),.SDcols=COL1NormFVNames]

compScatterplotly(dt, sig = "Spot_PA_SpotCellCountNormCOL1MedianNorm",title = "Comparison of RUV+COL1 Normalized Spot Cell Counts\n in the HMEC Cell Lines",limits=c(-.5,.7), sdInt = sd(MEPs$Spot_PA_SpotCellCountNormCOL1MedianNorm))


```

***

###Interactive Scatterplot of RUV+Col1 Normalized Proliferation

```{r, scatterPlotlyProliferation, fig.height=3,fig.width=4}

compScatterplotly(dt, sig = "Nuclei_PA_Gated_EdUPositiveProportionNormCOL1MedianNorm",title = "Comparison of RUV+COL1 Normalized Proliferation\n in the HMEC Cell Lines",limits=c(-.5,1), sdInt = sd(MEPs$Nuclei_PA_Gated_EdUPositiveProportionNormCOL1MedianNorm))

```

***


###Interactive Scatterplot of RUV+Col1 Normalized Lineage

```{r, scatterPlotlyLineage, fig.height=3,fig.width=4}

compScatterplotly(dt, sig = "Cytoplasm_PA_Gated_KRT19PositiveProportionNormCOL1MedianNorm",title = "Comparison of RUV+COL1 Normalized Lineage\n in the HMEC Cell Lines",limits=c(-1,.6), sdInt = sd(MEPs$Cytoplasm_PA_Gated_KRT19PositiveProportionNormCOL1MedianNorm))

```

***

###QA Figures
```{r}
#Show the row scc values and evaluate for filtering
dt <- l3[,ArrayRowSCC := numericMedian(Spot_PA_SpotCellCount), by=c("ArrayRow","Barcode")]
dt <- l3[,ArrayRowSCCNorm := numericMedian(Spot_PA_SpotCellCountNorm), by=c("ArrayRow","Barcode")]

p <- ggplot(dt, aes(x=ArrayRow, y=ArrayRowSCC, colour=CellLine))+
  geom_point()
p
p <- ggplot(dt, aes(x=ArrayRow, y=ArrayRowSCCNorm, colour=CellLine))+
  geom_point()
p
```

***